# 인프런 강의 수강

## Chapter 1-2. 운영체제가 뭐길래?
- 정보량 I(x) = -log2P(x) (I(x) : 정보량, P(x) : 일어날 확률)
- 정보의 저장은 플립플롭, 정보의 전송은 데이터 버스
- 덧셈은 반가산기, 전가산기 뺄셈은 2의 보수 표현, 곱셈과 나눗셈은 덧셈과 뺄셈의 반복
- 실수 연산은 부동 소수점 표현법
- 함수는 GOTO 사용
- 프로그램 : 명령어의 집합
- 운영체제도 일종의 프로그램임
  - 항상 실행 중인 프로그램
  - 시스템 서비스를 어플리케이션에 제공하는 프로그램
  - 프로세스, 자원, 유저 인터페이스 등을 관리하는 프로그램


## Charpter 1-2. Introduction & O/S structures.
- 운영체제는 컴퓨터 유저(프로그램)와 하드웨어의 중간다리 역할
- 운영체제의 정의
  - universial 한 정의는 없음
  - 일반적인 정의로는 항상 동작하고 있는 프로그램(ex. kernel)
- 전통적인 컴퓨터 시스템
  - cpu, disk controller, usb controller, graphics adapter가 버스를 통해 메모리와 통신
- 컴퓨터를 실행하면 가장 처음에 실행하는 프로그램 : bootstrap (운영체제를 메모리에 로딩해주는 역할)
- 인터럽트
  - 하드웨어가 언제라도 인터럽트를 trigger시킬 수 있음
  - 트리거 시키면 cpu에 신호를 보내줌
- 폰노이만 아키텍처
  - fetch 하고 , excute 하는 형태의 구조
- 속도 : registers > chche > main memory(RAM) > SSD > hard disk > optical disk > magnetic tapes
- 용량은 반대 순서
- 동영상을 유튜브에서 보여줄 때 인터넷에서 받아오는 건 network device가, 실행은 lcd 화면이 하기때문에 cpu는 할일이없어서 Direct Memory Access(DMA) 방식을 통해서 보여줌
- Symmetric multiprocessing : 한개의 메모리에 여러개의 cpu가 접근
- Multi-core design : 듀얼코어, 쿼드코어 등등 같은 프로세스 칩 하나에 여러개의 코어가 붙어있는것
- Multiprogramming : 여러개의 프로그램을 동시에 실행시키는 것을 멀티 프로그래밍이라고 한다. cpu 가용률을 높여줄 수 있음
- Multitasking(=multiprocessing) : 멀티프로그램의 논리적 확장 개념
  - cpu는 매우 빠르기 때문에 하나의 일만 처리하면 노는 시간이 많아질 수 있음
  - 시간을 쪼개서(시분할) 여러개의 작업을 동시에 처리
  - cpu 스케쥴링이 필요함(어떤 프로세스를 다음에 실행할 것인가)
- 운영체제는 2개의 모드가 존재함(user mode, kernel mode)
  - 유저의 프로세스가 실행하다가 시스템 콜을 하면 user mode 에서 kernel mode로 바껴서 시스템콜을 처리하고 user mode로 돌아감
  - kernel mode에서만 하드웨어를 제어할 수 있음
  - 일반 프로세스가 하드웨어를 제어해서 불순한 동작을 할 수 없음
- 가상화 (Virtualization)
  - 가상화는 하나의 컴퓨터에 여러개의 운영체제를 수행해주는 것
  - vitual machine을 관리하기 위해서 virtual machine manager가 존재함
  - 하드웨어 위에 VMM을 올리고 VM을 올려서 각각의 프로세스를 실행해주는 형태
- 컴퓨팅 환경의 종류
  - Traditional Computing, Mobile Computing, Client-Server Computing, Peer-to-Peer Computing, Cloud Computing, Real-Time Embedded Systems
  - P2P 컴퓨팅의 발전이 비트코인이라고 할 수 있음
- OS가 제공하는 일
  - User interface
  - Program execution
  - I/O operation
  - File-system manipulation
  - Communication
  - Error Detection
  - Resource allocation
  - Logging
  - Protection and Security
- 시스템 콜
  - os 가 제공해주는 서비스를 시스템콜을 통해 접근
  - OS가 제공하는 API를 시스템 콜이라고 보면 됨
  - 항상 시스템 콜을 작성하면 힘드니까 라이브러리를 통해서 제공해줌


## 1-2 퀴즈
- 1번 : 정보량 = -log2확률 = -log2(1/4) = 2
- 2번 : not, and, or 게이트로 모든 연산 가능 = 1, nand 게이트 하나면 모든 연산 구현 가능 = 5 
- 3번 : 튜링 머신은 정지 문제 풀기 불가능 = 3
- 4번 : 컴퓨터의 명령어의 집합을 프로그램이라고 한다 = 4
- 5번 : 운영체제의 코어는 커널 = 1
- 6번 : 컴퓨터에 운영체제를 로드해주는 프로그램은 부트스트랩 = 3
- 7번 : 하나의 하드웨어에 여러개의 운영체제를 띄우는 것은 가상화 = 1
- 8번 : 운영체제에서 사용할 수 있는 서비스에 대한 인터페이스를 제공해주는 것은 시스템 콜 = 1

## Chapter3. 03. 프로세스의 이해
- 프로세스는 실행중인 프로그램
- 프로세스는 운영체제의 일의 단위라고 보면 됨
- 프로세스는 수행을 위해 특정 자원이 필요함
  - cpu time
  - 메모리
  - 파일들
  - I/O 장치
- OS의 가장 기본적인 일은 프로세스를 관리하는 것
- 프로세스 메모리 구조는 몇개의 부분으로 나뉘어짐 
  - 텍스트 section(실행 코드)
  - 데이터 section(전역 변수)
  - 힙 section(동적 할당)
  - 스택 section(함수 파라미터, 반환 주소, 지역 변수등 저장)
- 프로세스는 5개의 라이프 사이클 상태가 존재 
  - New : 이제 막 프로세스가 생성된 상태
  - Running : 프로세스가 실행중인 상태
  - Waiting : 어떤 일이 발생하길 기다리고 있는 상태(ex. I/O 처리가 완료되길 기다림)
  - Ready : 실행되길 기다리고 있는 상태
  - Terminated : 종료
- New 상태에서 승인이 되면 ready 상태가 됨
- ready 상태에서 스케쥴러에 의해 디스패치되면 running 상태가 됨
- running 상태에서 i/o 이벤트가 발생하면 waiting, interrupt가 발생하면 ready, 끝나면 terminated상태가 됨
- waiting 상태에서 i/o 이벤트가 처리가 완료되면 다시 ready 상태가 됨
- 프로세스를 관리하기 위해서 PCB(Process Control Block)를 만들어서 관리
  - PCB는 각각의 프로세스가 가져야할 정보를 모두 가지고 있음
  - 프로세스 상태, 프로그램 카운터(다음에 수행할 명령어를 저장해두는 레지스터), CPU 레지스터, CPU 스케쥴링 정보, 메모리 관리 정보, 자원 오픈 정보 등 저장
- N개의 프로세스가 돌고있다면 N개의 PCB가 생성됨
- 프로세스는 싱글 쓰레드로 동작하는게 기본적인 구조임
- 싱글 쓰레드의 경우 하나의 업무만 한번에 처리 가능
- 그렇기에 멀티 테스킹과 멀티 쓰레딩이 필요함
- 한개의 프로세스에서도 여러개의 쓰레드로 수행되는 것이 필요함
- 쓰레드는 가벼운 프로세스라고 보면 됨
- 멀티 프로그래밍의 목적은 동시에 여러개의 프로세스를 수행시키는 것
  - CPU 사용률을 최대화 시키기 위해서
- 타임 쉐어링은 아주 작은 단위로 CPU 사용 시간을 쪼개서 동시에 처리하는 것처럼 보이게 하는 것
- 스케쥴링 큐
  - Ready Queue : 준비 상태인 프로세스들의 목록을 넣어둔 Queue
  - Waiting Queue : I/O를 기다리고 있는 목록을 넣어둔 Queue, Device가 여러개이기때문에 waiting 큐는 여러개
- 큐는 링크드 리스트로 구현해주면 됨
- CPU를 할당 받은 프로세스가 다시 Ready Queue로 돌아가는 경우
  - I/O 요청을 받고 처리가 완료된 경우
  - CPU 타임을 모두 사용한 경우
  - fork한 child가 실행이 완료된 경우
  - 인터럽트가 발생한 경우
- 실행중인 프로세스가 다른 프로세스로 전환이 일어날 때 Context Switch가 발생함
  - 현재 진행중인 프로세스의 상태를 저장하여 다음에 다시 그 부분부터 실행할 수 있도록 하며, 새로운 프로세스의 PCB를 복원함
- 운영체제는 프로세스를 생성하고 프로세스를 제거할 수 있어야함
- 프로세스는 여러 새 프로세스를 생성하며, 다른 프로세스를 생성하는 프로세스를 부모 프로세스, 생성당하는 프로세스를 자식 프로세스라고 부름
- 프로세스의 최상단에 init 프로세스(프로세스 번호 : 1)이 존재함
- 부모 프로세스는 일부 또는 모든 자식 프로세스가 종료될 때까지 wait함
- 부모와 같은 일을 하는 프로세스는 부모 프로세스의 주소공간을 그대로 복제함, 새로 할당할수도 있음
- 프로세스는 마지막 문장을 수행하거나 exit() 시스템 콜을 호출 시에 종료되며 OS는 메모리 등 자원을 회수함
- 부모 프로세스가 fork를 한 후에 wait를 안하고 끝나버리면 고아 프로세스가 되며, 부모 프로세스가 끝나진 않았는데 wait하지 않으면 자식 프로세스는 종료되면서 회수해갈 프로세스가 없어서 좀비 프로세스가 됨
- 