# 인프런 강의 수강

## Chapter 1-2. 운영체제가 뭐길래?
- 정보량 I(x) = -log2P(x) (I(x) : 정보량, P(x) : 일어날 확률)
- 정보의 저장은 플립플롭, 정보의 전송은 데이터 버스
- 덧셈은 반가산기, 전가산기 뺄셈은 2의 보수 표현, 곱셈과 나눗셈은 덧셈과 뺄셈의 반복
- 실수 연산은 부동 소수점 표현법
- 함수는 GOTO 사용
- 프로그램 : 명령어의 집합
- 운영체제도 일종의 프로그램임
  - 항상 실행 중인 프로그램
  - 시스템 서비스를 어플리케이션에 제공하는 프로그램
  - 프로세스, 자원, 유저 인터페이스 등을 관리하는 프로그램


## Charpter 1-2. Introduction & O/S structures.
- 운영체제는 컴퓨터 유저(프로그램)와 하드웨어의 중간다리 역할
- 운영체제의 정의
  - universial 한 정의는 없음
  - 일반적인 정의로는 항상 동작하고 있는 프로그램(ex. kernel)
- 전통적인 컴퓨터 시스템
  - cpu, disk controller, usb controller, graphics adapter가 버스를 통해 메모리와 통신
- 컴퓨터를 실행하면 가장 처음에 실행하는 프로그램 : bootstrap (운영체제를 메모리에 로딩해주는 역할)
- 인터럽트
  - 하드웨어가 언제라도 인터럽트를 trigger시킬 수 있음
  - 트리거 시키면 cpu에 신호를 보내줌
- 폰노이만 아키텍처
  - fetch 하고 , excute 하는 형태의 구조
- 속도 : registers > chche > main memory(RAM) > SSD > hard disk > optical disk > magnetic tapes
- 용량은 반대 순서
- 동영상을 유튜브에서 보여줄 때 인터넷에서 받아오는 건 network device가, 실행은 lcd 화면이 하기때문에 cpu는 할일이없어서 Direct Memory Access(DMA) 방식을 통해서 보여줌
- Symmetric multiprocessing : 한개의 메모리에 여러개의 cpu가 접근
- Multi-core design : 듀얼코어, 쿼드코어 등등 같은 프로세스 칩 하나에 여러개의 코어가 붙어있는것
- Multiprogramming : 여러개의 프로그램을 동시에 실행시키는 것을 멀티 프로그래밍이라고 한다. cpu 가용률을 높여줄 수 있음
- Multitasking(=multiprocessing) : 멀티프로그램의 논리적 확장 개념
  - cpu는 매우 빠르기 때문에 하나의 일만 처리하면 노는 시간이 많아질 수 있음
  - 시간을 쪼개서(시분할) 여러개의 작업을 동시에 처리
  - cpu 스케쥴링이 필요함(어떤 프로세스를 다음에 실행할 것인가)
- 운영체제는 2개의 모드가 존재함(user mode, kernel mode)
  - 유저의 프로세스가 실행하다가 시스템 콜을 하면 user mode 에서 kernel mode로 바껴서 시스템콜을 처리하고 user mode로 돌아감
  - kernel mode에서만 하드웨어를 제어할 수 있음
  - 일반 프로세스가 하드웨어를 제어해서 불순한 동작을 할 수 없음
- 가상화 (Virtualization)
  - 가상화는 하나의 컴퓨터에 여러개의 운영체제를 수행해주는 것
  - vitual machine을 관리하기 위해서 virtual machine manager가 존재함
  - 하드웨어 위에 VMM을 올리고 VM을 올려서 각각의 프로세스를 실행해주는 형태
- 컴퓨팅 환경의 종류
  - Traditional Computing, Mobile Computing, Client-Server Computing, Peer-to-Peer Computing, Cloud Computing, Real-Time Embedded Systems
  - P2P 컴퓨팅의 발전이 비트코인이라고 할 수 있음
- OS가 제공하는 일
  - User interface
  - Program execution
  - I/O operation
  - File-system manipulation
  - Communication
  - Error Detection
  - Resource allocation
  - Logging
  - Protection and Security
- 시스템 콜
  - os 가 제공해주는 서비스를 시스템콜을 통해 접근
  - OS가 제공하는 API를 시스템 콜이라고 보면 됨
  - 항상 시스템 콜을 작성하면 힘드니까 라이브러리를 통해서 제공해줌


## 1-2 퀴즈
- 1번 : 정보량 = -log2확률 = -log2(1/4) = 2
- 2번 : not, and, or 게이트로 모든 연산 가능 = 1, nand 게이트 하나면 모든 연산 구현 가능 = 5 
- 3번 : 튜링 머신은 정지 문제 풀기 불가능 = 3
- 4번 : 컴퓨터의 명령어의 집합을 프로그램이라고 한다 = 4
- 5번 : 운영체제의 코어는 커널 = 1
- 6번 : 컴퓨터에 운영체제를 로드해주는 프로그램은 부트스트랩 = 3
- 7번 : 하나의 하드웨어에 여러개의 운영체제를 띄우는 것은 가상화 = 1
- 8번 : 운영체제에서 사용할 수 있는 서비스에 대한 인터페이스를 제공해주는 것은 시스템 콜 = 1

## Chapter3. 03. 프로세스의 이해
- 프로세스는 실행중인 프로그램
- 프로세스는 운영체제의 일의 단위라고 보면 됨
- 프로세스는 수행을 위해 특정 자원이 필요함
  - cpu time
  - 메모리
  - 파일들
  - I/O 장치
- OS의 가장 기본적인 일은 프로세스를 관리하는 것
- 프로세스 메모리 구조는 몇개의 부분으로 나뉘어짐 
  - 텍스트 section(실행 코드)
  - 데이터 section(전역 변수)
  - 힙 section(동적 할당)
  - 스택 section(함수 파라미터, 반환 주소, 지역 변수등 저장)
- 프로세스는 5개의 라이프 사이클 상태가 존재 
  - New : 이제 막 프로세스가 생성된 상태
  - Running : 프로세스가 실행중인 상태
  - Waiting : 어떤 일이 발생하길 기다리고 있는 상태(ex. I/O 처리가 완료되길 기다림)
  - Ready : 실행되길 기다리고 있는 상태
  - Terminated : 종료
- New 상태에서 승인이 되면 ready 상태가 됨
- ready 상태에서 스케쥴러에 의해 디스패치되면 running 상태가 됨
- running 상태에서 i/o 이벤트가 발생하면 waiting, interrupt가 발생하면 ready, 끝나면 terminated상태가 됨
- waiting 상태에서 i/o 이벤트가 처리가 완료되면 다시 ready 상태가 됨
- 프로세스를 관리하기 위해서 PCB(Process Control Block)를 만들어서 관리
  - PCB는 각각의 프로세스가 가져야할 정보를 모두 가지고 있음
  - 프로세스 상태, 프로그램 카운터(다음에 수행할 명령어를 저장해두는 레지스터), CPU 레지스터, CPU 스케쥴링 정보, 메모리 관리 정보, 자원 오픈 정보 등 저장
- N개의 프로세스가 돌고있다면 N개의 PCB가 생성됨
- 프로세스는 싱글 쓰레드로 동작하는게 기본적인 구조임
- 싱글 쓰레드의 경우 하나의 업무만 한번에 처리 가능
- 그렇기에 멀티 테스킹과 멀티 쓰레딩이 필요함
- 한개의 프로세스에서도 여러개의 쓰레드로 수행되는 것이 필요함
- 쓰레드는 가벼운 프로세스라고 보면 됨
- 멀티 프로그래밍의 목적은 동시에 여러개의 프로세스를 수행시키는 것
  - CPU 사용률을 최대화 시키기 위해서
- 타임 쉐어링은 아주 작은 단위로 CPU 사용 시간을 쪼개서 동시에 처리하는 것처럼 보이게 하는 것
- 스케쥴링 큐
  - Ready Queue : 준비 상태인 프로세스들의 목록을 넣어둔 Queue
  - Waiting Queue : I/O를 기다리고 있는 목록을 넣어둔 Queue, Device가 여러개이기때문에 waiting 큐는 여러개
- 큐는 링크드 리스트로 구현해주면 됨
- CPU를 할당 받은 프로세스가 다시 Ready Queue로 돌아가는 경우
  - I/O 요청을 받고 처리가 완료된 경우
  - CPU 타임을 모두 사용한 경우
  - fork한 child가 실행이 완료된 경우
  - 인터럽트가 발생한 경우
- 실행중인 프로세스가 다른 프로세스로 전환이 일어날 때 Context Switch가 발생함
  - 현재 진행중인 프로세스의 상태를 저장하여 다음에 다시 그 부분부터 실행할 수 있도록 하며, 새로운 프로세스의 PCB를 복원함
- 운영체제는 프로세스를 생성하고 프로세스를 제거할 수 있어야함
- 프로세스는 여러 새 프로세스를 생성하며, 다른 프로세스를 생성하는 프로세스를 부모 프로세스, 생성당하는 프로세스를 자식 프로세스라고 부름
- 프로세스의 최상단에 init 프로세스(프로세스 번호 : 1)이 존재함
- 부모 프로세스는 일부 또는 모든 자식 프로세스가 종료될 때까지 wait함
- 부모와 같은 일을 하는 프로세스는 부모 프로세스의 주소공간을 그대로 복제함, 새로 할당할수도 있음
- 프로세스는 마지막 문장을 수행하거나 exit() 시스템 콜을 호출 시에 종료되며 OS는 메모리 등 자원을 회수함
- 부모 프로세스가 fork를 한 후에 wait를 안하고 끝나버리면 고아 프로세스가 되며, 부모 프로세스가 끝나진 않았는데 wait하지 않으면 자식 프로세스는 종료되면서 회수해갈 프로세스가 없어서 좀비 프로세스가 됨
- 

## Chapter3. 04. 프로세스 생성
- 유닉스같은 운영체제에서는 fork() 시스템콜을 통해서 새 프로세스를 생성함
- 부모 프로세스와 자식 프로세스는 fork()명령어 이후를 똑같이 실행함
- fork의 return 코드가 0이면 child 프로세스, 0이 아니면 parent 프로세스임
- fork 시스템 콜은 부모 프로세스는 자신의 실행을 계속 진행하거나 자식 프로세스가 실행되는 동안 wait할 수 있음
- 자식 프로세스를 기다리는 경우 waiting queue로 들어감
- 전역 변수를 자식 프로세스에서 바꾼다고 해도 부모 프로세스에는 변화가 없음(프로세스 메모리를 복제하는 것이기 때문에)
- fork()명령어를 연속해서 3번 수행할 경우에 프로세스는 총 8개가 됨
- 자식 프로세스에 다른 프로그램을 실행하게 하려면 execlp명령어를 실행하여 자식 프로세스를 덮어써주면 된다.
- execlp 아래의 명령어는 수행되지 않는다(메모리가 덮어씌워졌기 때문에)
- 자식 프로세스의 getpid()와 부모프로세스의 fork()실행한 명령어의 return 값은 같게 나온다

## Chapter3. 03-04: 퀴즈 #2
- 1번 : 프로그램이 실행되는 동안 다이나믹하게 할당되는 부분은 힙임 - 1
- 2번 : 레디 상태인데 인터럽트를 어캐걸지? - 2
- 3번 : BSS는 정적으로 할당된 세그먼트라는데 뭔진 모르겠음 - 5
- 4번 : 멀티 테스킹은 한번에 여러개처럼 하는거로 보이는거 - 2
- 5번 : WAITING 상태를 가져오는게 아니라 READY 상태를 가져오는 것 - 4
- 6번 : 부모 프로세스는 포크하고 자식 프로세스가 끝날때까지 기다린다 따라서 BD(손자)CD(자식)AD(부모) - 4
- 7번 : 1번 자식 20 2번자식 30 본인 20 - 2

## Chapter3. 05. 프로세스간 통신
- 프로세스간 통신을 IPC(Inter-Process Communication)라고 부름
- 프로세스는 독립적으로 수행되거나 협력해서 수행하는 두가지 방식이 있음
- 독립적으로 수행하는 경우에는 프로세스 스케쥴링만 잘해주면 됨
- 여러개의 프로세스가 협력해서 수행할 경우에는 협력하는 프로세스간에 커뮤니케이션을 어떻게 할 것인가도 중요함
- IPC는 데이터를 주고 받는 과정인데 데이터를 주거나 받는 동작 수행
- 두가지 모델이 존재함
  - 공유 메모리(shared memory)
  - 메시지 패싱(message passing)
- 공유 메모리 방식의 경우에 따로 공유 메모리를 지정해두어 각각 접근할 수 있도록 해주며, message passing의 경우에는 메시지 큐를 통해서 메시지 전달
- 공유 메모리의 경우 생산자 소비자 문제 고려 필요
  - 생산자는 정보를 생산하고, 소비자는 정보를 소비하는 모델
  - 생산자와 소비자 프로세스는 concurrently 하게 동작함
  - 버퍼를 사용하여 생산자는 버퍼에 데이터를 채우고, 소비자는 데이터를 소비하고 비우면 됨
  - 버퍼는 사이즈가 지정되어있기 때문에 버퍼가 가득차게되면 생산자는 wait하며, 비어있을 경우에는 소비자가 wait하고 있음
  - 순환 모형으로 버퍼를 만들어놓고 in, out의 위치를 가리키는 지시자를 만들고, in,out이 같으면 길이가 0인 것으로 판별하면 됨
- 메시지 패싱 방식은 우리는 메시지만 던지고 관리는 os가 알아서 해줌
- send(message), receive(message)만 있으면 됨
- 메시지 패싱은 두개의 프로세스말고 여러개의 프로세스가 통신하는 방식에서 메시지를 관리를 어떻게 할 것인가가 중요함
- 직접 커뮤니케이션 할것인가?, 동기적 방식으로 커뮤니케이션 할 것인가?, 자동으로 보내거나 명시적으로 버퍼링해서 보낼 것인가?
- direct 커뮤니케이션의 경우 명시적으로 상대방을 정해서 보내고, 받는 프로세스는 누구한테 받는지 명시해서 받음
- indirect 방식의 경우 원하는 mailbox에 메시지를 주고 원하는 mailbox에서 가져감
- os는 새로운 메일 박스를 만들거나 삭제하고, 메일박스에 send,receive 하는 동작으로 지원해줘야함
- blocking or non-blocking(synchronous or asynchronous) 방식
  - blocking send는 버퍼 사이즈가 부족해서 보내야하는 양을 모두 메일 박스에 보내지 못할 경우 다 보낼때까지 block됨
  - non-blocking send의 경우에는 명령어만 걸어놓고 다른 일 수행
  - receive도 동일함

## Chapter3. 06. 프로세스간 통신의 실제
- POSIX의 Shared Memory, Message Passing의 pipe를 통해 알아볼 것
- POSIX shared memory
  - 메모리 mapped file을 사용하기 위해서 만들어졌음
  - 공유 메모리 객체를 생성하고 -> 객체의 사이즈를 구성하고 -> memory-mapped file을 생성한다
  - 소비는 공유 메모리 객체를 열고, 공유 메모리 객체를 맵핑하고 읽은후 공유 메모리를 닫음
- shared memory 방식은 일일히 열고 공유하고 읽고 닫고를 스스로 해줘야하는데 파이프는 그냥 두개의 프로세스가 통신하는 구조
- 파이프는 구현하는데 4가지의 이슈가 있음
  - 단방향으로 할것인가 양방향으로 할것인가?
  - 전이중이냐 반이중이냐?
  - 통신하는 두 프로세스 사이에 관계가 있는가?(부모 자식 관계)
  - 네트워크에서 동작할 수 있는가?(네트워크에서 쓸수있는 파이프는 소켓)
- Ordinary pipe는 지정한 프로세스 외에 다른 프로세스가 접근 불가능 , 부모 프로세스가 파이프를 만들며, 자식 프로세스와 통신하겠다.
- named pipe는 이름이 지정된 파이프
- 양방향이면 부모입장에서 하나는 읽기용, 하나는 쓰기용으로 만들면 됨
- 소켓 통신은 ip 주소와 포트를 통해서 식별함
- java는 매우 쉬운 소켓 인터페이스를 제공함
  - socket class : TCP
  - datagramSocket class : UDP
  - multicast Socket


  ## Chapter3. 05-06: 퀴즈 #3
  - 1번 : ipc의 두개 모델은 공유 메모리와 메시지 패싱 - 1
  - 2번 : 생산자가 생성하고 소비자가 데이터를 소비하는 구조로 공유 메모리를 만들면 생산자 소비자 문제가 없어짐 - 4
  - 3번 : 메일 박스를 사용하는 이유는 indirect 통신을 하기 위함임 - 4
  - 4번 : ordinary pipe는 두개의 프로세스가 통신하는 파이프로 부모가 자식과 통신하기 위해서 만듬 - 4
  - 5번 : 소켓의 식별은 ip+port - 3


## Chapter4. 07. 쓰레드의 이해
- 프로세스는 지금까지는 싱글 스레드인 구조라고 보면됨
- 프로세스 하나가 여러개의 쓰레드로 구성되어있을 수 있음
- 스레드는 light weigth process라고 보면 됨
- cpu를 점유하는 가장 기본적인 단위가 쓰레드임
- thread id, pc, register set, stack 등으로 이루어짐
- 멀티 쓰레드는 싱글 쓰레드 프로세스와 같이 code, data, files는 하나만 들어있고, register, stack, pc는 각각 따로 갖는다
- 클라이언트가 요청을 하면 서버는 쓰레드를 생성해서 쓰레드가 처리하게하고 자기는 다음일을 처리함
- 쓰레드의 장점
  - responsiveness: 프로세스가 블락되있지 않고 쓰레드에 처리시키고 진행할 수 있음
  - resource sharing : 쓰레드들은 프로세스의 코드와 데이터 영역을 공유하기 때문에 자원 공유에 더 편함
  - economy : 큰 코드를 복사해서 새로운 영역에 만드는 프로세스보다 훨씬 경제적임
  - scalability : 병렬처리 가능
- 멀티 코어 시스템에서 멀티 쓰레딩을 하는 것은 복잡해짐
  - 멀티 코어에서는 동시성이 좋아짐
  - 동시에 병렬적으로 처리가능(단 쪼개서 동시에 처리할 수 있는 프로세스가 뭔지 잘 확인할 수 있어야함)
  - 벨런싱을 해주는 작업이 필요하고, 데이터를 쪼개는 방법도 중요함, 데이터들의 의존성도 확인 중요
  - 테스트와 디버깅이 매우 어려워짐
  - 코어는 무조건 많으면 많을수록 좋은것은 아님
  - 코어의 갯수가 늘어나면 늘어날수록 효율은 점점 떨어짐(암달의 법칙) - 전부다 병렬처리할 수는 없기 때문에
  

## Chapter4. 08. 멀티 쓰레딩
- 쓰레드는 두개의 타입의 쓰레드가 존재 - user 쓰레드, kernel 쓰레드
- 유저쓰레드는 유저가 , kernel 쓰레드는 커널모드에서 커널이 생성한 쓰레드
- 유저 쓰레드와 커널 쓰레드의 관계는 many to one, one to one, many to many 모델이 존재
- 쓰레드 라이브러리는 쓰레드를 생성하고, 관리하는 api를 제공함
- pthread는 포직스 표준에서 제공(c에서 사용)
- ptread_attr_init, pthread_create, pthread_join 등의 명령어 제공

## Chapter4. 07-08. 퀴즈 #4
- 1번 : 암달의 법칙은 1/ ((1-p) + p/s) 임 1/(0.4 + 0.3) = 1.428 ..... 1/(0.4 + 0.15) = 1.81.... - 1
- 2번 : many to one 모델은 다수의 유저쓰레드를 하나의 커널쓰레드에서 지원해주는 것 - 2
- 3번 : 멀티 쓰레드에서 공유하는 것은 힙메모리와 글로벌 변수 - 2,3
- 4번 : 자원 공유가 유리한 이유는 쓰레드간에 shared 메모리를 사용할 수 있기 때문이지 프로세스끼리 공유는 아님 - 2
- 5번 : run 메소드를 직접 호출하지 않고 start 메소드 사용 - 3
- 6번 : 쓰레드를 미리 생성해두지는 않음 - 4
- 7번 : 자식 쓰레드 만들고 부모 프로세스는 기다림 자식 프로세스는 쓰레드 하나 만들어서 runner 실행해서 +10 포크하고 부모는 기다리고 자식은 프린트하니까 20, 그다음 부모가 10더하고 출력이니 30, 조상은 아무 계산도 안일어났으니 10 - 2
- 8번 : b 출력하고 쓰레드를 시작하지만 join은 안해서 c 실행 gkrh join해서 aaa실행 그다음 d 실행 - 1